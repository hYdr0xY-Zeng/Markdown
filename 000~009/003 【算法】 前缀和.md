# 前缀和

~~哈哈在学这个之前我居然就用过这个思想解决问题了,我是小(大)天(ba)才(ka)~~

可简单理解为数列前n项和

---

## 一维前缀和

**为什么用前缀和？**
比如在数组 `a[n]` 中我们 需要求`m`次某段区间所有`a[i]`的和, 这时我们的复杂度来到了 $O(mn)$ ,但我们实际上可以以前缀和`S[n]`的形式来存这个数组

$S_n = \sum_{i=1}^{n} a_i$

这时我们求 $[l,r]$ 区间和 只需`S[r] - S[l - 1]`,单次操作复杂度来到了 $O(1)$

还可以形象理解: `a[i]`存的是相邻点的线段长度, 而`S[i]`存的是点坐标

[![pVLNTE9.png](https://s21.ax1x.com/2025/10/18/pVLNTE9.png)](https://imgchr.com/i/pVLNTE9)

代码(一般在输入阶段就做好前缀和的储存)~~这么简单真的要板子嘛~~
```cpp
void prefix_sum()
{
    S = a;
    // std::partial_sum(a.begin(), a.end(), S.begin());
    for (int i = 1; i <= n; ++i)
        S[i] += S[i - 1];
}


int query(int l, int r) 
{
    return S[r] - S[l - 1];
}
```

## 二维前缀和

一样的思想，但是需要用到**容斥原理**

**我们定义**
$S(i, j) = \sum_{i' = 1}^{i' \leq i}\sum_{j' = 1}^{j' \leq j}A(i', j')$

怎么求任意一个**二维区间**的总和呢?
首先我们给出**二维区间**的两个顶点 $[(i_1, j_1), (i_2, j_2)]$

[![pVLN7NR.png](https://s21.ax1x.com/2025/10/18/pVLN7NR.png)](https://imgchr.com/i/pVLN7NR)

**注意：不要简单理解为面积， 而是一整个集合元素的求和**

- **绿色部分**为所求
- 用**整个部分**减去**红色部分**和**黄色部分**
- 此时重叠的**橙色部分**被减了两次
- 把**橙色部分**加一个回来

然后我们就有
$S_{[(i_1, j_1), (i_2, j_2)]} = S(i_2, j_2) - S(i_1 - 1, j_2) - S(i_2, j_1 - 1) + S(i_1 - 1, j_1 - 1)$

同样单次操作复杂度为$O(1)$

**注意：需要补一行`0`和一列`0`防止越界**

---

## 逐维前缀和

一样的想法, 等我用到了再仔细写写笔记吧

---

## 差分

往往与前缀和一起使用
前缀和的逆操作，我们可以把`S`返回为`a`
很像离散的求导和积分

**那么我们是不是还可以“求二阶导”呢？**
[洛谷P4321 三步必杀](https://www.luogu.com.cn/problem/P4231)

给出`diff[n] = a[n] - a[n - 1]`

用来干嘛呢?

我们做对**一整个区间**的数据做修改,比如我们希望对 $[l,r]$ 这个区间内所有的数`+x`, 那么对`a[]`进行操作,单次操作的复杂度为`O(n)`

但如果我们调整`diff[]`呢
- `diff[l] += x`
- `diff[r + 1] -= x`

复杂度变为了 $O(1)$

[![pVLNTE9.png](https://s21.ax1x.com/2025/10/18/pVLNTE9.png)](https://imgchr.com/i/pVLNTE9)

还是这个图, 现在我们把`S`看成`a`, 把`a`看`diff`
如果我们“拉长或缩短” 一个`diff`看看会发生什么

代码~~感觉没必要写这个板子~~
```cpp

void diff()
{
    for (int i = 0; i < n; i++)
    {
        diff[i] = a[i] - a[i - 1];
    } 
}

void mdf(int l, int r, int x)
{
    diff[l] += x;
    if (r < n) diff[r + 1] -= x;
}
//还原只需prefix_sum()即可
```

同理想一想**二维差分**,**逐维差分**,就多了个容斥而已

二维差分进行修改操作代码
```cpp

int x1, y1, x2, y2;
for (int i = 1; i <= m; i++)
{
    scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
    diff[x1][y1]++;
    diff[x2 + 1][y1]--;
    diff[x1][y2 + 1]--;
    diff[x2 + 1][y2 + 1]++;
}
```

***但是还原的时候不要用[定义](#二维前缀和)还原, 全加起来复杂度直接来到了 $O(m^2n^2)$***

还原时我们和一维一样要利用**递推**


代码
```cpp

void prefix_sum(void)
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {    
            //这个就是递推
            diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
            printf("%d ", diff[i][j]);    
        }
        printf("\n"); 
    }            
}
```



~~就这?~~
~~来道题咱就不吱声了~~
[P8228 「Wdoi-5」模块化核熔炉](https://www.luogu.com.cn/problem/P8228)

---

总之
- **前缀和:** 做区间求和
- **差分:** 做区间修改

---

## 树上前缀和/差分

我们来看看 004, 很有意思