# P2294 [HNOI2005](https://www.luogu.com.cn/problem/P2294) 狡猾的商人

## 题目描述

刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了 $n$ 个月以来的收入情况，其中第 $i$ 个月的收入额为 $a_i$，$i=1,2,\ldots,n-1,n$。当 $a_i>0$ 时表示这个月盈利 $a_i$ 元，当 $a_i<0$ 时表示这个月亏损 $|a_i|$ 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。

刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。

现在，姹总共偷看了 $m$ 次账本，当然也就记住了 $m$ 段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。

## 输入格式

第一行为一个正整数 $w$，其中 $w<100$，表示有 $w$ 组数据，即 $w$ 个账本，需要你判断。

每组数据的第一行为两个正整数 $n$ 和 $m$，其中 $n<100,m<1000$，分别表示对应的账本记录了多少个月的收入情况以及偷看了多少次账本。

接下来的 $m$ 行表示刁姹偷看 $m$ 次账本后记住的 $m$ 条信息，每条信息占一行，有三个整数 $s,t$ 和 $v$，表示从第 $s$ 个月到第 $t$ 个月（包含第 $t$ 个月）的总收入为 $v$，这里假设 $s$ 总是小于等于 $t$。

## 输出格式

包含 $w$ 行，每行是 `true` 或 `false`，其中第 $i$ 行为 `true` 当且仅当第 $i$ 组数据，即第 $i$ 个账本不是假的；第 $i$ 行为 `false` 当且仅当第 $i$ 组数据，即第 $i$ 个账本是假的。

## 输入输出样例 #1

### 输入 #1

```
2
3 3
1 2 10
1 3 -5
3 3 -15
5 3
1 5 100
3 5 50
1 2 51
```

### 输出 #1

```
true
false
```

# 怎么想?

我们注意到很重要的一个特征, 那就是翻账本只能翻看一个***连续的时间段***, 并且翻看的结果是这个时间段收支的***总和***

哎!***多次连续区间求和***
我们于是想到了**前缀和**

但是不一样的地方在于, 我们无从得知原数组, 我们只能从给出的区间和推导 **是否存在一个数组使得能满足给定的区间和**

但正向找数组的一个解并不容易, 但我们可以想满足什么样的条件**一定无解**

我们再用一遍这个图:

[![pVLNTE9.png](https://s21.ax1x.com/2025/10/18/pVLNTE9.png)](https://imgchr.com/i/pVLNTE9)

我们先输入`3 5 6`
代表 `a[3] + a[4] + a[5] = 6` 即 `S[5] - S[2] = 6`

我们再输入`3 7 9` 
代表 `S[7] - S[2] = 9`

**注意: 第一个数要减 $1$**

这时我们已经建立了`S[2], S[5], S[7]`之间的 **联系**

我们当然可以求出`S[7] - S[5] = 3`
这时如果我们输入了`5 7 d (d != 3)`
矛盾便出现了

我们总结一下矛盾出现的条件
1. 输入的两个数`i j`间已经 **建立了联系**
2. **建立了联系** 意味着 若 $i, j \in {联系}$ 我们一定能够求出`S[j] - S[i]`
3. 输入的值为`d` , 当`d != S[j] - S[i]`, 矛盾产生

接下来我们一一解决矛盾的判定

---

## 一、怎么判断`i j`已经**建立联系**?

好熟悉啊, 那我们把 **联系** 这个词替换成 **集合** ,这不就是 ***并查集*** 吗

把每次输入视为一次 `merge(i, j)` 我们只要`find(i - 1)`和`find(j)` 判定是否为同一根节点即可

---

## 二、怎么求`S[j] - S[i - 1]`?
现在我们已经判定了`(i - 1) j`在同一个集合

我们也得到了它们共属集合的**根** `root`

啊要是我们知道每个点到根的距离就好了
我们需要一个`dist[]`存储了**节点到父节点的距离**

此乃 **带权(路径长度)并查集** 

我们期望得到这样一颗树, 深度为 $1$

[![pVLNOgK.png](https://s21.ax1x.com/2025/10/18/pVLNOgK.png)](https://imgchr.com/i/pVLNOgK)

这样`S[j] - S[i - 1] == dist[j] - dist[i - 1]`

直接连到根节点?

我们想到了 **路径压缩**

于是我们需要在`find()`中对`dist`进行维护
即把到根的路径上所有的`dist` 都加起来

```cpp
int find(int a)
{
    if (a == father[a]) 
        return a;
    int tmp = find(father[a]);//一找根
    dist[a] += dist[father[a]];//二维护dist
    return father[a] = tmp;//三路径压缩
}
```
$
$
具象化这个过程
[![pVLNXjO.png](https://s21.ax1x.com/2025/10/18/pVLNXjO.png)](https://imgchr.com/i/pVLNXjO)

那我们怎么把输入的`d` 通过`merge()`存到`dist[]`呢?
最后我们`merge()`的是两个根节点不是两个输入的节点啊


我们可以把`d`视作一个暂时的**联系**
当作我们已经`father[j] = i - 1` , 则`d == dist[j]`
显然我们很好求出两个根的距离
而且我们还在`find()`中做了**路径压缩**
`find()`之后结构相当好看

[![pVLNL36.png](https://s21.ax1x.com/2025/10/18/pVLNL36.png)](https://imgchr.com/i/pVLNL36)

**注意`d`的方向，我们是把`d`当作`dist[j](暂定)`看的**

那么`dist[root2] = d + dist[i - 1] - dist[j]`

现在我们会维护`dist`了, `S[j] - S[i - 1]`手到擒来

---

## 三、判定矛盾

我们只需要在`merge()`中加一个判定就好
`merge()`的根本逻辑现在成了这样
- 如果`(i - 1) j`不在同一集合, 则合并
- 如果在同一集合, 判定`(d == dist[j] - dist[i - 1]) ?`


代码
```cpp

bool fake = false;

void merge(int i, int j, int d)
{
    int f1 = find(i - 1);
    int f2 = find(j);
    if (f1 != f2)
    {
        father[f2] = f1;
        dist[f2] = d + dist[i - 1] - dist[j];
    }
    else if (dist[i - 1] - dist[j] != d)
    {
        fake = true;
    }
}
```

恭喜你发明了[***树上前缀和***](https://oi-wiki.org/basic/prefix-sum/#%E6%A0%91%E4%B8%8A%E5%89%8D%E7%BC%80%E5%92%8C '看看OI WIKI 吧')


***AC!!!***