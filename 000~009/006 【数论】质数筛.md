# 质数筛

---
## 埃式筛

**复杂度:** $O(n\log\log n)$
由于公因数导致的重复操作增加了复杂度

```cpp
void Eratosthenes(int N)
{
    memset(is_prime, true, sizeof(is_prime));
    //初始为全开, 后续利用因数进行关闭操作
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= N; i++)
        if (is_prime[i])
            for (int j = i * i; j <= N; j += i)//见下方
                is_prime[j] = false;
}
```
$
$
**为什么从 $i^2$ 开始筛?**

因为合数 $i * k(k < i)$ 已经被 $k$ 或 $k$的因子筛掉了

用`bitset<>`进行位级压缩优化(不要用`vector<bool>`)
在数据量较小时性能会超过欧拉筛线性筛。

---
## 欧拉筛/线性筛（重点）

我们需要
- `bool is_Prime[N]` 初始为 **全开**
- `int Prime[M]` 用于记录目前已经确定的质数(不含 $1$ )

我们的核心问题是解决埃式筛中的重复问题, 让算法复杂度来到 $O(n)$

基本原理: 我们用每一个合数的**最小质因子**来筛选

即把 `N` 拆成 `i * prime[j]`

```cpp
void Euler(int N)
{
	memset(isPrime, 1, sizeof(isPrime));
	
	isPrime[1] = 0;
	
	for(int i = 2; i * i <= N; i++)
	{
		if(isPrime[i])//执行到这一步还没被筛掉一定是质数
        {
			Prime[++cnt] = i; //只有这一步在添加质数
        }
		for(int j = 1; (j <= cnt)/*遍历目前已知质数*/ && (i * Prime[j] <= N)/*范围内*/; j++) 
		{
			isPrime[i * Prime[j]] = 0;
			if(i % Prime[j] == 0) break;//最关键的需要理解的一步，见下方
		}
	}
}
```

**为啥要 `break`**

注意到以下事实:
1. `i >= Prime[j]`, 因为我们先`Prime[++cnt] = i`之后才有 `Prime[j]`, 而且如果 `i < Prime[j]`, `Prime[j]`也就不是最小质因数了
2. 注意我们的循环外层是遍历 `i`(倍数) ,内层遍历`Prime[j]`, 质数
3. 如果 `i % Prime[j] == 0`, 我们可以把这个数拆成`i * Prime[j] * Prime[j]`
4. 此时我们若不退出循环,`j++` 我们下一个会筛 `i * Prime[j - 1] * Prime[j]`
5. `Prime[j] >= Prime[j - 1]` 这个数的最小公因数不再是`Prime[j]` ,而之后当 `i(new) = i * Prime[j]` 时, 这个数又会被筛一次, 这并没有达到线性筛的目的



