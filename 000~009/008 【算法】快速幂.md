# 快速幂

---
## 想法

感觉有一点倍增的思想在里面

对于 $x^n$ , 我们可以把 $n$ 写成二进制形式, 或者可以说是把 $n$ 分解为 $\sum_{i = 0}^{k} 2^i a_i$

那么我们便可以把 $x^n$ 分解成 $\prod_{i = 0}^{k} x^{2^i a_i}$

eg:如 $5^{11} = 5^{(1011)_2} = 5^{2^0} \cdot 5^{2^1} \cdot 5^{2^3}$

---

## 代码

在算法中我们便可以通过更换底数实现运算次数的优化
- 在循环中对 `n` 进行左移操作, 直到遍历完 `n` 的所有二进制位, 也就是 `n == 0`
- 每一次循环的底数 `base` 为上一个循环的平方
- 如果目前 `n` 的二进制位为 $1$ 则将 `ans` 乘上当前基

```cpp

typedef long long ll;
ll fastpow(ll base, ll n)
{
    ll ans = 1;
    while (n)
    {
        if ((n & 1) != 0)
        {
            ans = ans * base;
        }
        base *= base;
        n >>= 1;
    }
    return ans;
}
```

一般来说需要快速幂的题目数据很大往往还需要取模, 于是我们边乘边模即可

```cpp

typedef long long ll;
const ll MOD = 233333;
ll fastpow(ll base, ll n)
{
    ll ans = 1;
    while (n)
    {
        if ((n & 1) != 0)
        {
            ans = ans * base % MOD;
        }
        base = base * base % MOD;
        n >>= 1;
    }
    return ans;
}
```

矩阵乘法也可以使用快速幂, 比如接下来是一段Fibonacci数列的 $O(\log n)$ 时间复杂度解法

```cpp

//这个是矩阵乘法, 顺带就在这写了
vector<vector<int>> multmat(const vector<vector<int>>& A, const vector<vector<int>>& B) 
{
    int rowsA = A.size();
    int colsA = A[0].size();
    int colsB = B[0].size();
    vector<vector<int>> result(rowsA, vector<int>(colsB, 0));

    for (int i = 0; i < rowsA; ++i) 
    {
        for (int j = 0; j < colsB; ++j) 
        {
            for (int k = 0; k < colsA; ++k) 
            {
                result[i][j] += A[i][k] * B[k][j];
            }
        }
    }
    return result;
}


int Fib(int n)
{
    if (n < 1)
        return -1;
    if (n == 1 || n == 2)
        return 1;
    vector<vector<int>> base(2, vector<int>(2, 1));
    vector<vector<int>> ans(2, vector<int>(2));
    base[1][1] = 0;
    ans[0][0] = 1;
    ans[1][1] = 1;
    n = n - 2;
    
    //fastpow
    while (n)
    {
        if ((n & 1) != 0)
        {
            ans = multmat(base, ans);
        }
        base = multmat(base, base);
        n >>= 1;
    }

    return ans[0][0] + ans[0][1];
}
```