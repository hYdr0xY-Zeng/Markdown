# 搜索

本质上是一种 **状态枚举** , 不同的状态之间以 **树**(**图**) 的形式连接, 所以纯粹的搜索往往在比赛中只能拿部分分, 复杂度往往为指数级, 因此会存在很多优化形式, 如 **双向搜索** , **剪枝** 等等

---

## DFS(搜索)

适用于
- 构造一个解
- 遍历图
- 获得所有解
- 解的数量
- 最优解（BFS一般更擅长干这个）

相比于**BFS**, **DFS**能更快搜索到终点, 构造 **DFS** 往往结合回溯法与剪枝, 往往需要利用递归(或栈模拟实现)

在图论中相当于 **前序遍历**

这里给出 **回溯法** DFS的一般模板
```cpp
void DFS(int dep/*参数不一定是深度, 重在于能表示当前状态*/)
{
    //一定要写退出
    if (dep > MAXDEP/*根据当前状态参数判断搜索是否结束*/)
    {
        //记录/输出解 or 比较目前最优解并决定是否更新最优解
        return;
    }
    for (/*下一层所有情况, 不一定用循环, 也可以是分支*/)
    {
        if (/*下一个状态合法(未越界, 未访问……)*/)
        {
            //记录当前状态为 已访问;
            DFS(dep + 1/*或下一个状态的参数*/);
            //回溯状态为 未访问;(如果是遍历则无需回溯)
        }
    }
    /*完成搜索后自动回溯到上一层*/
}

```

---

## BFS(搜索)

适用于
- **找最优解**
- 遍历图
- 找所有解
- 解的数量
- 构造一个解(让DFS来干这个吧)


在图论中相当于 **层序遍历**

由于要记录一层所有节点的信息, (对应DFS的 **栈** 模拟, BFS用 **队列** 模拟), 相对于DFS空间复杂度更高, 但找到的第一个解就是 **深度最小解(最优解)** , 如果题目要求找最优, 后面的情况就不需要遍历了, 于是时间复杂度一般优于DFS

```cpp

queue<Type> Q;
void BFS(Type S/*start 状态参数*/)
{
    Q.push(S);
    Type now, son;
    while (!Q.empty())
    {
        now = Q.front()
        Q.pop();
        for (/*遍历所有子状态*/)
        {
            son = /*子状态参数*/;
            if (/*子状态合法(未越界, 未访问……)*/)
            {
                if (son == /*end 状态参数*/)
                {
                    //记录/输出解;
                    return;
                }
                //维护数据(如深度, 父节点等);
                Q.push(son);
            }
        }
    }
}

```

---

## 双向搜索

**Meet in the Middle**

从起点状态和终点状态同时开始搜索, 相遇时把两端的路径合并为一组解

这里先以 **BFS** 为例~~因为双向DFS还没做到过, 也还没理解其意义~~

用 meet in the middle 算法, 复杂度的指数可以减半，让复杂度从 
$O(m^n)$ 降到 $O(m^{n/2})$

[![pVzfO4H.png](https://s21.ax1x.com/2025/11/01/pVzfO4H.png)](https://imgchr.com/i/pVzfO4H 'Meet in the Middle')

[![pVzh9Df.png](https://s21.ax1x.com/2025/11/01/pVzh9Df.png)](https://imgchr.com/i/pVzh9Df 'pure BFS')

比如上图
- 每个点表示一个 **状态**, 状态之间存在联系(未画出)
- $A$ 为始状态 $B$ 为末状态

显然直接BFS需要搜索更多次, 存储更多 **无用状态**

```cpp

queue<Type> Q;
void BFS(Type S/*start 状态参数*/,Type F/*end 状态参数*/)
{
    Q.push(S);
    //维护S(见下方重点需要维护的数据)
    Q.push(F);
    //维护F
    Type now, son;
    while (!Q.empty())
    {
        now = Q.front()
        Q.pop();
        for (/*遍历所有子状态*/)
        {
            son = /*子状态参数*/;
            if (/*子状态合法(未越界, [当前树]未访问……)*/)
            {
                if (Meet/*在另一棵树上被访问过了*/)
                {
                    // [合并] 解(如果要输出解的方案的话这一步会稍微有点麻烦)
                    return;
                }
                //维护数据;
                Q.push(son);
            }
        }
    }
}

```

**重点维护数据**
1. 根状态(是从起点搜出来的还是终点搜出来的): 用于判断重复/相遇
   - 起点树 $1$
   - 终点树 $2$
   - 未被发掘 $0$
2. 父状态: 用于在找到相遇点时, 从相遇点逆向回溯获取方案
3. 深度: 用于判断根, 得出最优解的总深度

更多细节见[洛谷P1225黑白棋游戏](https://www.luogu.com.cn/problem/P1225 '吊塔润神秘常数题')

---

## 迭代加深深搜

多设置一个深度上限 `limit`, 当 `dep > limit` 直接返回, 若仍未搜到解, 则 `limit++` 并回到根节点重新深搜

本质上是DFS, 但可以某种程度模拟 BFS 的效果, 且降低 BFS 指数级爆炸增涨的空间复杂度

优点
- 在找最优解时, 相比 DFS 可能减少搜索次数(极端情况可能退化)
- 相比 BFS 空间上只需 DFS 的空间

缺点
- 较浅层会被反复搜索

~~等我用到了再给板子, 说实话感觉很鸡肋~~
