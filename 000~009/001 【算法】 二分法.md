# **二分法**

**为什么二分法老容易写错？**
**怎么死循环了？**

---
## 一、避免出错（整形）
于是我们仔细讨论一下二分法的上下界`left`和`right`以及二分的`mid`

在这里我们先就讨论一个最简单的找数问题,在一个***从小到大*** 排好的 ***整形*** 数组`num`中找到某个数。

这时我们能生成这样一个`judge()`函数
```C++
bool judge(int mid)
{
    return mid <= target;
}
```
在这里我们把**不大于要找的数**视为`true`, 反之为`false`

然后我们来写`find()`
这里我们给出三种理解

### 理解1
- 目标在在闭区间`[left, right]`内
- `mid = (left + right) / 2`
- 如果`find(mid)`,即此时我们确定目标在闭区间`[mid, right]`内, 更新区间, `left = mid`
- 如果没找到,此时目标区间为`[left, mid)`, 更新区间, `right = mid - 1` (`right` 永远不会和`mid` 重合)
- 当集合中仅剩一个元素时退出，即`right == left`

但若出现`left == right - 1`, 由于对于***整形***的除法是整除,`mid = (left + right) / 2`依然为`left`, 于是我们就一直卡在这了, 上不去下不来。

Pass!!!

### 理解2
- 目标在在左闭右开区间`[left, right)`内
- `mid = (left + right) / 2`
- 如果`find(mid)`,即此时我们确定目标在闭区间`[mid, right）`内, 更新区间, `left = mid`
- 如果没找到,此时目标区间为`[left, mid)`, 更新区间, `right = mid`
- 当集合中仅剩一个元素时退出，即`left + 1 == right`


注意left才是答案
这个没问题，但我不喜欢

### 理解3
- 在闭区间`[left, right]`内进行选择, 但目标不一定在该区域内
- `mid = (left + right) / 2`
- 定义变量`ans`, 用于储存上一个满足条件的数
- 如果`find(mid)`,那么我们先将这个潜在的可能答案记录下来, `ans = mid`, 然后在区间`(mid, right]`内, 更新区间, `left = mid + 1`
- 如果没找到,此时在区间为`[left, mid)`, 更新区间, `right = mid - 1`
- 当集合中没有元素时退出，即`left > right`, 返回`ans`

***注意: 这样查ans总是在区间外部, 直到找到下一个符合要求的元素才会更新***

OK我就按这个写板子了

```cpp
//judge() 需根据题目条件生成
int find(int l, int r)
{
    int mid, ans;
    while (l <= r)
    {
        mid = (l + r) / 2;
        if (judge(mid))
        {
            ans = mid;
            l = mid + 1;
        }
        else
        {
            r = mid - 1;
        }
    }
    return ans;
}
```

---

## 非整形（实数域）

~~其实反而变简单了~~
比如找函数零点（中学就讲了是说），此时我们给出一个精度的要求`eps`
当`right - left <= eps`时退出循环
(其实可以理解为*整形*的`eps`为 `1` , 在刚才[理解2](#理解2)的基础上, 即当`right - left <= 1`时退出, 几乎一样)

代码
```cpp
//一样其实写judge()更关键
double eps = 1e-6;
double find(double l, double r)
{
    while (r - l > eps)
    {
        mid = (l + r) / 2;
        if (judge(mid))
            l = mid;
        else
            r = mid;
    }
    return left;
}
```

---

## STL

C++ 标准库中实现了查找首个不小于给定值的元素的函数 `std::lower_bound` 和查找首个大于给定值的元素的函数 `std::upper_bound`，二者均定义于头文件 `<algorithm>` 中
二者均采用二分实现，所以调用前必须保证元素有序。
(所以可以直接`map.upper_bound`, `set.lower_bound`等)

`lower_bound(begin, end, num)` 从数组的 `begin` 位置到 `end - 1` 位置二分查找第一个 ***大于等于*** `num` 的数字，找到返回该数字的地址，不存在则返回 `end`。

`upper_bound(begin, end, num)`: 从数组的 `begin` 位置到 `end - 1` 位置二分查找第一个 ***大于*** `num` 的数字，找到返回该数字的地址，不存在则返回 `end`

***注意: 返回值为迭代器/指针, end不能解引用记得特判***

那么怎么找第一个 ***小于 / 小于等于*** `num` 的数字?
`prev(it)` / `it--` 即可

***注意: `begin` 是有元素的, 如果所有元素都大于等于 /大于 `num` ,用`prev()` / `it--`会越界, 记得特判***

---

## 三分查找

用于凸 / 凹函数寻找极值
***注意： 区间内一定要为单峰函数***

此时我们把区间分成三份
- 每次在闭区间`[l, r]`内进行选择
- `lmid = l + (r - l) / 3` `rmid = r - (r - l) / 3`
- 如果 $f(lmid)<f(rmid)$，则极值点一定在区间 `(l,rmid)`；如果 $f(lmid)>f(rmid)$，则极值点一定在区间 `(lmid,r)`

![如图](https://oi-wiki.org/basic/images/ternary.svg)

代码
```cpp
double f(double x);//某个区间内单峰函数

double find(double l, double r)
{
    while(r - l > eps)
    {
        lmid = l + (r - l) / 3, rmid = r - (r - l) / 3;
        if(f(m1) < f(m2))//找最大
            l = lmid;
        else
            r = rmid;
    }
    return f(l);
}
```

事实上我们可以优化为黄金分割[参考](https://oi-wiki.org/basic/binary/)