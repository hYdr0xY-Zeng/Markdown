# 0-1背包问题

- 有一个容量为 `C` 的背包
- 有 `M` 个重量为 `w[i]` , 价值为 `v[i]` 的物品
- **物品不能分割**(可分割背包问题用贪心算法即可解决)
- 求背包可装的最大价值

---

## 动态规划分析

这个问题可以被分割成一些 **子问题** , 并且 **子问题** 间存在某种联系

最暴力的想法就是直接 **DFS** 搜索每一个物品的 **0-1状态(取或不取)**, 复杂度为 $O(2^n)$, 很吓人

我们看看怎么DP

我们定义 `P[i][j]` 表示在前 $i$ 个物品里取, 在容量为 $j$ 的背包里能装的最大价值。

那么我们最终的答案就是 `P[M][C]`

对于 `P[i][j]` 我们讨论在这个**最大价值**的状态下, 我们讨论是否取了物品 `i` , 可以得到**动态转移方程**
1. 如果没有取 物品`i` 便可达到最大价值, 那么该物品对当前解 `P[i][j]` 无任何贡献, 于是有 `P[i][j] = P[i - 1][j]`
   1. `w[i] > j` , 即哪怕`i`之前所有的物品都不拿, 容量`j`都装不下, 那一定不拿 `i`
   2. `w[i] <= j` , 假设拿了 `i` , 比较拿与不拿那种价值更高取 `max()`
2. 如果**最大价值**是取了 `i` 的情况, 有 `P[i][j] = P[i - 1][j - w[i]] + v[i]`


我们整理得:

$
P[i][j] = 
\begin{cases}
P[i - 1][j] & \text{, } w[i] > j \\
\max(P[i - 1][j], P[i - 1][j - w[i]] + v[i]) & \text{, } w[i] <= j
\end{cases}
$

那么代码就呼之欲出了
```cpp

for (int i = 1; i <= M ; i++)
{
    for (int j = 1; j <= C; j--)
    {
        if (w[i] > j) 
            P[i][j] = P[i - 1][j];
        else 
            P[i][j] = max(P[i - 1][j], P[i - 1][j - w[i]] + v[i]);
    }
}
```

**注意: 开数组的第0行和第0列均为0 (容量为0则装不下任何物品, 0个物品也没得装)**

---

## 拓展与优化

### 1. 怎么得到具体方案

我们只需判定 `P[i][j] > P[i - 1][j]`
- 成立则取了物品`i`, 追溯到 `P[i - 1][j - w[i]]`
- 否则没取, 追溯到 `P[i - 1][j]`

```cpp

bool take[M + 1] = {0};//记录方案的数组

int j = C;
for (int i = M; i > 0; i--)
{
    if (P[i][j] > P[i - 1][j])
    {
        take[i] = true;
        j -= w[i];
    }
    else take[i] = false;
}

```

### 2. 一维滚动数组

若我们只需求解 `P[M][C]`, 中间的过程无需一一记录, 那么我们用一个 **滚动(即 实时跟新)** 的一维数组 `P[C]` 就可以达成目的, 我们可以用 **下标** 来表示 **当前容量**, **外层循环的次数** 表示正在讨论的物品的选取

**注意: 滚动更新的内层循环应从 `P[C]` 开始逆向更新**

因为对于 `P[j]` , 未更新时处于上一层循环的状态, 等价于二维数组中 `P[i - 1][j]`, 更新后则等价于 `P[i][j]`

而更新时我们相当于可能需要访问 `P[i - 1][j - w[i]]`, 此时我们要确保 `P[j - w[i]]` 未更新

```cpp
for (int i = 1; i <= M ; i++)
    {
        //注意逆向循环
        for (int j = T; j >= 1; j--)
        {
            if (w[i] <= j)
                P[j] = max(P[j], P[j - w[i]] + v[i]);
        }
    }
```