# 0-1背包问题

- 有一个容量为 `C` 的背包
- 有 `M` 个重量为 `w[i]` , 价值为 `v[i]` 的物品
- **物品不能分割**(可分割背包问题用贪心算法即可解决)
- 求背包可装的最大价值

---

## 动态规划分析

这个问题可以被分割成一些 **子问题** , 并且 **子问题** 间存在某种联系

最暴力的想法就是直接 **DFS** 搜索每一个物品的 **0-1状态(取或不取)**, 复杂度为 $O(2^n)$, 很吓人

我们看看怎么DP

我们定义 `P[i][j]` 表示在前 $i$ 个物品里取, 在容量为 $j$ 的背包里能装的最大价值。

那么我们最终的答案就是 `P[M][C]`

**子问题**分析
1. **最优子结构:** 我们可以换成一个更好听的名字叫 **后无效性** , 此时第 $i$ 个物品的选取不会影响前面 $i - 1$ 个物品的选择结果, 也就是说如果 `P[i - 1][]` 不是最优解, 那么由它转移状态到 `P[i][j]` 也不可能是最优
2. **子问题重叠:** (这个并非DP求解的必要条件, 但若满足重叠性更能体现DP的优势) 若我们逆向求解 `P[M][C]`, 中间的确会出现多次被调用的子问题


对于 `P[i][j]` 我们讨论在这个**最大价值**的状态下, 我们讨论是否取了物品 `i` , 可以得到**动态转移方程**
1. 如果没有取 物品`i` 便可达到最大价值, 那么该物品对当前解 `P[i][j]` 无任何贡献, 于是有 `P[i][j] = P[i - 1][j]`
   1. `w[i] > j` , 即哪怕`i`之前所有的物品都不拿, 容量`j`都装不下, 那一定不拿 `i`
   2. `w[i] <= j` , 假设拿了 `i` , 比较拿与不拿那种价值更高取 `max()`
2. 如果**最大价值**是取了 `i` 的情况, 有 `P[i][j] = P[i - 1][j - w[i]] + v[i]`


我们整理得:

$
P[i][j] = 
\begin{cases}
P[i - 1][j] & \text{, } w[i] > j \\
\max(P[i - 1][j], P[i - 1][j - w[i]] + v[i]) & \text{, } w[i] <= j
\end{cases}
$

那么代码就呼之欲出了
```cpp

for (int i = 1; i <= M ; i++)
{
    cin >> w >> v;
    for (int j = 1; j <= C; j--)
    {
        if (w[i] > j) 
            P[i][j] = P[i - 1][j];
        else 
            P[i][j] = max(P[i - 1][j], P[i - 1][j - w] + v);
    }
}
```

**注意: 开数组的第0行和第0列均为0 (容量为0则装不下任何物品, 0个物品也没得装)**

---

## 拓展与优化

### 1. 怎么得到具体方案

我们只需判定 `P[i][j] > P[i - 1][j]`
- 成立则取了物品`i`, 追溯到 `P[i - 1][j - w[i]]`
- 否则没取, 追溯到 `P[i - 1][j]`

```cpp

bool take[M + 1] = {0};//记录方案的数组

int j = C;
for (int i = M; i > 0; i--)
{
    if (P[i][j] > P[i - 1][j])
    {
        take[i] = true;
        j -= w[i];
    }
    else take[i] = false;
}

```

### 2. 一维滚动数组

若我们只需求解 `P[M][C]`, 中间的过程无需一一记录, 那么我们用一个 **滚动(即 实时跟新)** 的一维数组 `P[C]` 就可以达成目的, 我们可以用 **下标** 来表示 **当前容量**, **外层循环的次数** 表示正在讨论的物品的选取

**注意: 滚动更新的内层循环应从 `P[C]` 开始逆向更新**

因为对于 `P[j]` , 未更新时处于上一层循环的状态, 等价于二维数组中 `P[i - 1][j]`, 更新后则等价于 `P[i][j]`

而更新时我们相当于可能需要访问 `P[i - 1][j - w[i]]`, 此时我们要确保 `P[j - w[i]]` 未更新

```cpp
for (int i = 1; i <= M ; i++)
{
    cin >> w >> v;
    //注意逆向循环
    for (int j = C; j >= w/*放不下则直接继承状态*/; j--)
    {
        P[j] = max(P[j], P[j - w] + v);
    }
}
```

---

# 完全背包问题

- 有一个容量为 `C` 的背包
- 有 `M` **种** 重量为 `w[i]` , 价值为 `v[i]` 的物品可无限取
- 物品不能分割
- 求背包可装的最大价值

---

由于物品无限取, $i$ 状态变成了物品的种数, 那么换句话来说我们可以直接在 **当前层** 进行状态转移, 当物品 $i$ 一个都装不下时, 我们继承 $i - 1$ 层的状态

我们只需要做一点小小的改动

$
P[i][j] = 
\begin{cases}
P[i - 1][j] & \text{, } w[i] > j \\
\max(P[i - 1][j], P[i][j - w[i]] + v[i]) & \text{, } w[i] <= j
\end{cases}
$

由于在当前层, 滚动时我们要求 `P[j - w[j]]` 已经更新, 而 `P[j]` 未更新(显然), 我们内层只需 **顺序** 递推即可

```cpp
for (int i = 1; i <= M ; i++)
{
    cin >> w >> v;
    for (int j = w; j <= C; j++)
    {
        P[j] = max(P[j], P[j - w] + v);
    }
}
```

同样我们可以求得方案
- 判定 `P[i][j] > P[i - 1][j]`
- 成立则取了物品`i`, 追溯到 `P[i][j - w[i]]`
- 否则没取, 追溯到 `P[i - 1][j]`

```cpp

int take[M + 1] = {0};//记录方案的数组

int j = C;
for (int i = M; i > 0; i--)
{
    while (P[i][j] > P[i - 1][j])
    {
        take[i]++;
        j -= w[i];
    }
}

```
---

# 多重背包问题

- 有一个容量为 `C` 的背包
- 有 `M` **种** 重量为 `w[i]` , 价值为 `v[i]` 的物品, 每种有 `k[i]` 个
- 物品不能分割
- 求背包可装的最大价值

最简单的想法是直接转化为 [0-1背包](#0-1背包问题)

但我们可以利用二进制对 **物品个数** 进行优化(又是倍增)

比如我们有这样的一次输入 `1 1 600` 表示有 $600$ 个同样的物品

那么我们 **最少** 可以用 $10$ 个物品的选取来表示 $600$ 个物品的选取

|i|w[i]|v[i]|
|:-:|:-:|:-:|
|1|1|1|
|2|2|2|
|3|4|4|
|4|8|8|
|5|16|16|
|6|32|32|
|7|64|64|
|8|128|128|
|9|256|256|
|10|89|89|

这样我们用一个二进制数实现了一个向 $600$ 的 **满射**

```cpp

//在输入时动一点手脚
for (int i = 1; i <= M; i++)
{
    cin >> w >> v >> k;
    //分部
    int base = 1, part = 1;
    int dw[MAXPART] = {0};
    int dv[MAXPART] = {0};
    while (k >> part)
    {
        dw[part] = w * base;
        dv[part] = v * base;
        part++;
        base <<= 1;
    }
    base = k - base + 1;
    dw[part] = w * base;
    dv[part] = v * base;
    
    for (int ii = 1; ii <= part; ii++)
        for (int j = C; j >= dw[ii]; j--)
            dp[j] = max(dp[j], dp[j- dw[ii]] + dv[ii]);
}

```

---

来切[洛谷P1833](https://www.luogu.com.cn/problem/P1833)