# P2224 [HNOI2001] 产品加工

## 题目描述

某加工厂有 A、B 两台机器，来加工的产品可以由其中任何一台机器完成，或者两台机器共同完成。由于受到机器性能和产品特性的限制，不同的机器加工同一产品所需的时间会不同，若同时由两台机器共同进行加工，所完成任务又会不同。

某一天，加工厂接到  $n$ 个产品加工的任务，每个任务的工作量不尽一样。

你的任务就是：已知每个任务在 A 机器上加工所需的时间  $t_1$，B 机器上加工所需的时间  $t_2$ 及由两台机器共同加工所需的时间  $t_3$，请你合理安排任务的调度顺序，使完成所有  $n$ 个任务的总时间最少。

## 输入格式

第一行为一个整数  $n$。

接下来  $n$ 行，每行三个非负整数  $t_1,t_2,t_3$，分别表示第  $i$ 个任务在 A 机器上加工、B 机器上加工、两台机器共同加工所需要的时间。如果所给的时间  $t_1$ 或  $t_2$ 为  $0$ 表示任务不能在该台机器上加工，如果  $t_3$ 为  $0$ 表示任务不能同时由两台机器加工。

## 输出格式

仅一行一个整数，表示完成所有  $n$ 个任务的最少总时间。

## 说明/提示

对于所有数据，有  $1\le n\le 6\times 10^3$， $0\le t_1,t_2,t_3\le 5$。

---

## 问题分析

1. **搜索?** 直接DFS包TLE的 $O(3^n)$
2. **贪心?** 
   1. 总是选择耗时最短的方式? No
   2. 优先平衡两台机械负载? 无法保证全局最优, No
3. **分冶?** 没有明显分割点, 且无法合并子问题
4. **动态规划? ~~真难啊nmd~~** DP的信号是什么?~~(多做题)~~
   - [ ] 计数问题: "多少方案?"
   - [x] 最值/最优问题
   - [x] 一系列相关决策
   - [x] 重叠子问题

怎么设计 **子问题/状态** ? 
1. 识别重要变量/状态: 
   1. 已处理任务数 $i$
   2. A 机械累计时间
   3. B 机械累计时间
2. 优化状态: 列举所有状态 `dp[i][a][b]` 空间过大, 且就算滚动优化降维 `dp[a][b]`, 时间复杂度也来到了 $O(n^3)$
   - 然而我们只关注 `max(a, b)`, 注意到信息的冗余
   - 固定 $a$ , 我们只需关心最小的 $b$

也就是说假设我们强制让 A 工作一个固定的时间 `j`(哪怕让 A 空转), 此时我们要让 B 工作时间尽可能短, 我们才能得到该状态下尽可能小的 `max(a, b)`

于是我们设计出了 `dp[i][j]` 表示前 `i` 个产品加工时, 固定 A 加工时间 `j` , B加工的最小时间, 并滚动优化为 `dp[j]`

这满足一个 **最优子结构**，可以进行 **状态转移**(转移后的最优解包含其子问题最优解)

最后我们要求的答案便是 `min{max(dp[j], j)}` 

---

## 状态转移方程

从 `i - 1` 到 `i` 我们有三个选择
- A来做: `dp[j] = dp[j - t1]`
- B来做: `dp[j] = dp[j] + t2`
- AB一起做: `dp[j] = dp[j - t3] + t3`

我们记录这三个状态并取 `dp[j] = min({})`即可

## 细节调整优化

1. `t == 0` 时是不能工作的, 要对 `0` 进行特判
2. 我们固定的 A 工作时间 `j` 可能连让 A 只处理(或与 B 共同处理)当前(第 $i$ 个)产品都不够, 这时`dp[j - t1]` 和 `dp[j - t3]`便会越界(`j < t1` 或 `j < t3`), 此时关于 A 的一些状态转移方案就不存在了
3. 对于全局最大处理时间不会超过 `const int INF = 30005`
4. 对于 $i$ 轮循环内部, 我们可以维护一个上界 `uplim += max(t1, t3)` 就是说把最坏的时长全部安排让 A 做, 那么我们在滚动时可以直接从 `j = uplim` 开始往前更新
5. 除了 `dp[0] = 0` 其他初始化为 `INF`

---

代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int n;

int dp[30005];

const int INF = 30005;

int main(void)
{
    std::ios::sync_with_stdio(false);
    int uplim = 0;
    int t1, t2, t3;
    memset(dp, INF, sizeof(dp));
    dp[0] = 0;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> t1 >> t2 >> t3;
        uplim += max(t1, t3);

        for (int j = uplim; j >= 0; j--)
        {
            //dp[j - t1]
            //dp[j] + t2
            //dp[j - t3] + t3
            int S1 = INF, S2 = INF, S3 =INF;
            if (t1 != 0 && j >= t1) S1 = dp[j - t1];
            if (t2 != 0) S2 = dp[j] + t2;
            if (t3 != 0 && j >= tCo) S3 = dp[j - t3] + t3;

            dp[j] = min({S1, S2, S3});
        }
    }

    int ans = INF;

    for (int i = 1; i <= uplim; i++)
        ans = min(ans, max(dp[i], i));
    
    cout << ans << endl;
    
    return 0;
}
```