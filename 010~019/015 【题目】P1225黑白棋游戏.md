# P1225 黑白棋游戏

## 题目描述

黑白棋游戏的棋盘由 $4 \times 4$ 方格阵列构成。棋盘的每一方格中放有 $1$ 枚棋子，共有 $8$ 枚白棋子和 $8$ 枚黑棋子。这 $16$ 枚棋子的每一种放置方案都构成一个游戏状态。在棋盘上拥有 $1$ 条公共边的 $2$ 个方格称为相邻方格。一个方格最多可有 $4$ 个相邻方格。在玩黑白棋游戏时，每一步可将任何 $2$ 个相邻方格中棋子互换位置。对于给定的初始游戏状态和目标游戏状态，编程计算从初始游戏状态变化到目标游戏状态的最短着棋序列。

## 输入格式

输入文件共有 $8$ 行。前四行是初始游戏状态，后四行是目标游戏状态。每行 $4$ 个数分别表示该行放置的棋子颜色。“ $0$ ”表示白棋；“ $1$ ”表示黑棋。

## 输出格式

输出文件的第一行是着棋步数 $n$。接下来 $n$ 行，每行 $4$ 个数分别表示该步交换棋子的两个相邻方格的位置。例如，abcd 表示将棋盘上 $(a,b)$ 处的棋子与 $(c,d)$ 处的棋子换位。

## 输入输出样例 #1

### 输入 #1

```
1111
0000
1110
0010
1010
0101
1010
0101
```

### 输出 #1

```
4
1222
1424
3242
4344
```

## 说明/提示

由 @zhouyonglong 提供 SPJ

---

~~被吊塔润神秘常数薄纱了~~
这是一个想法不难但**细节**巨多的题
输入输出也很搞人

---

## 思路分析

- 首先, 用一个二维数组存一个只有01的棋盘太浪费了, 而且要花更多时间在状态的比较上, 所以 [**状压**](#细节一-输入与状压 '细节一') 是跑不了的, 我们用一个二进制数整形存就行了

- **求最优解** 首先想到 **BFS**

- 对于 **状态之间的联系** , 当前状态可以经过 [**24种交换**](#细节二-状态的转换与输出 '细节二') 达到其子状态, 但并没有 $24$ 个那么多子状态, 我们需要 **判重**

- 现在还是有点担心子状态太多, 不敢写, 那么尝试优化为 [**双向BFS**](#细节三-双向bfs的维护与方案的生成 '细节三')

想法很好, 但这题细节太搞人了

---

## 很多细节

---

### 细节一: 输入与状压

这个题输入一行四个数连一块的

```
1111
0000
1110
0010
1010
0101
1010
0101
```

我们考虑用字符串接收, 合并, 再把字符串转化为二进制

```cpp
int main(void)
{
    string line, x;
    line.clear();
    for (int i = 0; i < 4; i++)
    {
        cin >> x;
        line += x;
    }
    Beg = stoi(line, nullptr, 2);//记一下, 省去自己写的功夫
    line.clear();
    for (int i = 0; i < 4; i++)
    {
        cin >> x;
        line += x;
    }
    End = stoi(line, nullptr, 2);

    /*
    算法求解
    */
    /*
    输出
    */
    return 0;
}
```

---

### 细节二: 状态的转换与输出

我们需要有一个二进制数两个bit位交换的函数用于在 `BFS()` 中搜索子状态

```cpp
inline int bit_swap(int a, int b, int num)
{
    if (a < b) swap(a, b);//注意: 须保证左右移运算右侧操作数不为负
    int x = num & (1 << a);
    int y = num & (1 << b);
    num = num - x - y + (x >> (a - b)) + (y << (a - b));
    return num;
}

```

然后这个题输出长这样
我们最后的方案也需要用多个四位数表示的

```
4
1222
1424
3242
4344
```

一共 $24$ 种交换方式, 包括 $12$ 种行交换, $12$ 种列交换
- 行交换: `bit_swap(i, i - 1, now)`
- 列交换: `bit_swap(i, i + 4, now)`

直接由 `i` 运算产生对应的 **四位数表示的交换方式** 很不划算, 也不方便

而 $24$ 种并不算多, 我们直接给按照 `BFS()` 中遍历子状态的顺序, 给每一种交换进行编号, 用数组做成 **映射**

```cpp
int EX[24] = { 4443, 4342, 4241, 3433, 3332, 3132, 2423, 2322, 2221, 1413, 1312, 1211, 4434, 4333, 4232, 4131, 3424, 3323, 3222, 3121, 2414, 2313, 2212, 2111};
```

---

### 细节三: 双向BFS的维护与方案的生成

**重点维护数据**
1. 根状态(是从起点搜出来的还是终点搜出来的): 用于判断重复/相遇
   - 起点树 $1$
   - 终点树 $2$
   - 未被发掘 $0$
2. 深度: 用于判断根, 得出最优解的总深度
3. 父状态: 用于在找到相遇点时, 从相遇点 **逆向回溯**
4. 交换操作: 用于回溯时 **生成方案**

```cpp
struct NODE
{
    int ori;
    int dep;
    int pre;
    int mov;
};

NODE tag[65535];//由表示状态的二进制数映射到其特征参数

```

在 `BFS()` 中如是实现维护
```cpp
queue<int> Q;
int BFS(int S, int F)
{
    if (S == F) return 0;
    //0 undiscovered, 1 start, 2 end
    Q.push(S);
    tag[S].ori = 1;
    //tag[S].dep = 0;
    //tag[S].pre = 0;
    //tag[S].mov = 0;
    Q.push(F);
    tag[F].ori = 2;
    //tag[F].dep = 0;
    //tag[F].pre = 0;
    //tag[F].mov = 0;
    int now, son;
    while (!Q.empty())
    {
        now = Q.front();
        Q.pop();

        int cnt = 0;//to record index of sons, also the index of exchange(EX[cnt])

        //row exchange
        for (int i = 0; i < 16; i++)
        {
            if (i % 4 == 0) continue;
            
            son = bit_swap(i, i - 1, now);
            //judge if son is overlaped
            if (tag[son].ori != tag[now].ori)
            {
                if (tag[son].ori)
                {
                    get_plan(now, son, EX[cnt]);//following
                    return tag[son].dep + tag[now].dep + 1;
                }
                tag[son].pre = now;
                tag[son].mov = EX[cnt];
                tag[son].dep = tag[now].dep + 1;
                tag[son].ori = tag[now].ori;
                Q.push(son);
            }
            cnt++;
        }
        //col exchange
        for (int i = 0; i < 12; i++)
        {
            son = bit_swap(i, i + 4, now);
            if (tag[son].ori != tag[now].ori)
            {
                if (tag[son].ori)
                {
                    get_plan(now, son, EX[cnt]);
                    return tag[son].dep + tag[now].dep + 1;
                }
                tag[son].pre = now;
                tag[son].mov = EX[cnt];
                tag[son].dep = tag[now].dep + 1;
                tag[son].ori = tag[now].ori;
                Q.push(son);
            }
            cnt++;
        }
    }
    return -1;
}
```

当 **Meet in the Middle** 时, 我们需要生成的方案由三部分组成
1. $(now -> S)^{-1}$ (-1次方表示逆序, 1为顺序)
2. $(now -> son)^{1}$ (即`EX[cnt]`)
3. $(son -> F)^{1}$

我们用 `stack<int> plan_rev` 做逆序处理, 并用一个 `vector<int> plan` 记录方案

```cpp

vector<int> plan;
stack<int> plan_rev;

void get_plan(int mid1, int mid2, int connect)
{
    //我们并不知道是起点树搜到了终点树, 还是终点树搜到了起点树
    //于是进行判断, 确保mid1来自起点树, mid2来自终点树
    if (tag[mid1].ori == 2) swap(mid1, mid2);
    //第一部分
    while (tag[mid1].dep)
    {
        plan_rev.push(tag[mid1].mov);
        mid1 = tag[mid1].pre;
    }
    //逆转
    while(!plan_rev.empty())
    {
        plan.push_back(plan_rev.top());
        plan_rev.pop();
    }
    //第二部分
    plan.push_back(connect);
    //第三部分
    while (tag[mid2].dep)
    {
        plan.push_back(tag[mid2].mov);
        mid2 = tag[mid2].pre;
    }
}
```

接下来输出只需遍历一下数组就好了

---

~~终于过了, 真难调啊~~
